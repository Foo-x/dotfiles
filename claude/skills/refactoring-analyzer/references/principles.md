# プログラミング原則

コード品質を評価する際の基本的な原則とガイドラインを提供します。

## SOLID原則

### 1. Single Responsibility Principle（単一責任原則）
**定義**: クラスは変更の理由を1つだけ持つべきである。

**違反の兆候**:
- クラス名に「Manager」「Handler」「Utility」「Helper」
- 複数の異なるインターフェースを実装
- メソッド名が「and」「or」で繋がれている

**検出ポイント**: クラスの責任をリストアップし、2つ以上の変更理由があれば違反

---

### 2. Open/Closed Principle（オープン・クローズドの原則）
**定義**: ソフトウェアエンティティは拡張に対して開いており、修正に対して閉じているべき。

**違反の兆候**:
- 新機能追加のたびに既存コードを修正
- 長いif-elseやswitch文
- 型チェックによる分岐処理

**検出ポイント**: 新しいバリエーション追加時に既存コードの修正が必要なら違反

---

### 3. Liskov Substitution Principle（リスコフの置換原則）
**定義**: 派生クラスは基底クラスと置換可能でなければならない。

**違反の兆候**:
- サブクラスがスーパークラスのメソッドで例外をスロー
- サブクラスで親のメソッドが空実装
- サブクラスがメソッドの前提条件を強化

**検出ポイント**: 基底クラスを派生クラスで置き換えても正常に動作するか検証

---

### 4. Interface Segregation Principle（インターフェース分離の原則）
**定義**: クライアントは使用しないメソッドに依存すべきではない。

**違反の兆候**:
- インターフェースの一部のメソッドしか使用しない実装が多い
- 空実装やNotImplementedExceptionが多い
- 単一のインターフェースが多数のメソッドを持つ

**検出ポイント**: 実装クラスで使用されていないメソッドがあれば違反

---

### 5. Dependency Inversion Principle（依存性逆転の原則）
**定義**: 上位モジュールは下位モジュールに依存すべきではない。両者は抽象に依存すべき。

**違反の兆候**:
- 具象クラスへの直接的な依存
- `new`演算子の多用
- グローバル変数への依存

**検出ポイント**: 具象クラスに直接依存し、抽象を介していない場合は違反

---

## 基本原則

### DRY（Don't Repeat Yourself）
**定義**: 知識の重複を避け、単一の信頼できる情報源を持つべき。
**違反の兆候**: 同じコードブロックが複数箇所、同じ定数が複数箇所で定義
**効果**: 変更が1箇所で済む、バグリスク減少

### KISS（Keep It Simple, Stupid）
**定義**: 設計はできるだけシンプルに保つべき。
**違反の兆候**: 過度な抽象化、使われていない機能、複雑なデザインパターンの不適切な使用
**効果**: コードが理解しやすい、保守が容易

### YAGNI（You Aren't Gonna Need It）
**定義**: 現在必要でない機能は実装すべきではない。
**違反の兆候**: 使われていない抽象化レイヤー、「将来必要かも」で実装されたコード
**効果**: コードが簡潔、保守コスト削減

---

## 設計原則

### 関心の分離（Separation of Concerns）
**定義**: プログラムを異なる関心事に分割し、各部分が1つの関心事のみを扱う。
**違反の兆候**: ビジネスロジックとプレゼンテーションの混在、データアクセスとビジネスロジックの混在
**効果**: 各レイヤーが独立してテスト可能、変更の影響範囲が限定

### デメテルの法則（Law of Demeter）
**定義**: オブジェクトは直接の知り合いとのみ会話すべき。
**違反の兆候**: メソッドチェーンの乱用（`a.getB().getC().doSomething()`）、2つ以上の「.」が連続
**効果**: 疎結合な設計、内部構造の変更が容易

### Composition over Inheritance（継承よりコンポジション）
**定義**: クラスの再利用は継承よりもコンポジションを優先すべき。
**違反の兆候**: 深い継承階層（3階層以上）、継承が「is-a」でなく「has-a」
**効果**: 柔軟な機能組み合わせ、継承の制約から解放

### 純粋関数（Pure Functions）
**定義**: 関数は副作用を持たず、同じ入力に対して常に同じ出力を返すべき。
**違反の兆候**: グローバル変数の読み書き、引数の変更、I/O操作、現在時刻への依存
**効果**: テスト容易、予測可能、並行処理で安全

---

## パッケージ設計の原則

### パッケージ凝集度の原則

| 原則 | 定義 | 違反の兆候 |
|------|------|-----------|
| **REP（再利用・リリース等価）** | 再利用の単位はリリースの単位と一致すべき | パッケージ内に関連性のないクラスが混在 |
| **CRP（共通再利用）** | 一緒に再利用されるクラスを同じパッケージに | パッケージの一部の機能しか使わないクライアントが多い |
| **CCP（共通閉鎖）** | 同じ理由・タイミングで変更されるクラスを同じパッケージに | 1つの機能追加で複数パッケージを変更 |

### パッケージ結合度の原則

| 原則 | 定義 | 違反の兆候 |
|------|------|-----------|
| **ADP（非循環依存関係）** | パッケージの依存関係グラフに循環があってはならない | ビルド順序が定まらない、単独でテストできない |
| **SDP（安定依存）** | 不安定なパッケージから安定したパッケージへ依存すべき | 安定したパッケージが不安定なパッケージに依存 |
| **SAP（安定抽象化）** | パッケージの抽象度は安定度に比例すべき | 安定したパッケージに具象クラスのみ |

### 安定度と抽象度の測定

**不安定性メトリクス（I）**: `I = Ce / (Ca + Ce)`
- Ce: 外向きの依存（このパッケージが依存する他のパッケージ数）
- Ca: 内向きの依存（このパッケージに依存する他のパッケージ数）
- I = 0: 完全に安定、I = 1: 完全に不安定

**抽象度（A）**: `A = 抽象クラス・インターフェース数 / 全クラス数`
- A = 0: 完全に具象的、A = 1: 完全に抽象的

**Main Sequence距離（D）**: `D = |A + I - 1|`
- D < 0.3: 許容範囲（理想的）
- D > 0.3: 改善推奨

### パッケージ設計の適用

1. **既存コードの分析**: 依存関係グラフ可視化、循環依存検出、安定度・抽象度測定
2. **問題箇所の特定**: Main Sequenceから外れているパッケージ、循環依存箇所
3. **段階的リファクタリング**: 循環依存解消（ADP）→パッケージ分割/統合（REP, CRP, CCP）→抽象化導入（SAP）

### 検出ツール
- JavaScript/TypeScript: madge, dependency-cruiser
- Java: jdepend, ArchUnit
- Python: pydeps
- Go: go mod graph
- C#: NDepend
