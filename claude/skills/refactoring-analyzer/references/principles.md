# プログラミング原則

コード品質を評価する際の基本的な原則とガイドラインを提供します。

## SOLID原則

### 1. Single Responsibility Principle（単一責任原則）
**定義**: クラスは変更の理由を1つだけ持つべきである。

**違反の兆候**:
- クラス名に「Manager」「Handler」「Utility」「Helper」
- 複数の異なるインターフェースを実装
- メソッド名が「and」「or」で繋がれている

**検出ポイント**: クラスの責任をリストアップし、2つ以上の変更理由があれば違反

---

### 2. Open/Closed Principle（オープン・クローズドの原則）
**定義**: ソフトウェアエンティティは拡張に対して開いており、修正に対して閉じているべき。

**違反の兆候**:
- 新機能追加のたびに既存コードを修正
- 長いif-elseやswitch文
- 型チェックによる分岐処理

**検出ポイント**: 新しいバリエーション追加時に既存コードの修正が必要なら違反

---

### 3. Liskov Substitution Principle（リスコフの置換原則）
**定義**: 派生クラスは基底クラスと置換可能でなければならない。

**違反の兆候**:
- サブクラスがスーパークラスのメソッドで例外をスロー
- サブクラスで親のメソッドが空実装
- サブクラスがメソッドの前提条件を強化

**検出ポイント**: 基底クラスを派生クラスで置き換えても正常に動作するか検証

---

### 4. Interface Segregation Principle（インターフェース分離の原則）
**定義**: クライアントは使用しないメソッドに依存すべきではない。

**違反の兆候**:
- インターフェースの一部のメソッドしか使用しない実装が多い
- 空実装やNotImplementedExceptionが多い
- 単一のインターフェースが多数のメソッドを持つ

**検出ポイント**: 実装クラスで使用されていないメソッドがあれば違反

---

### 5. Dependency Inversion Principle（依存性逆転の原則）
**定義**: 上位モジュールは下位モジュールに依存すべきではない。両者は抽象に依存すべき。

**違反の兆候**:
- 具象クラスへの直接的な依存
- `new`演算子の多用
- グローバル変数への依存

**検出ポイント**: 具象クラスに直接依存し、抽象を介していない場合は違反

---

## 基本原則

### DRY（Don't Repeat Yourself）
**定義**: 知識の重複を避け、単一の信頼できる情報源を持つべき。
**違反の兆候**: 同じコードブロックが複数箇所、同じ定数が複数箇所で定義
**効果**: 変更が1箇所で済む、バグリスク減少

### KISS（Keep It Simple, Stupid）
**定義**: 設計はできるだけシンプルに保つべき。
**違反の兆候**: 過度な抽象化、使われていない機能、複雑なデザインパターンの不適切な使用
**効果**: コードが理解しやすい、保守が容易

### YAGNI（You Aren't Gonna Need It）
**定義**: 現在必要でない機能は実装すべきではない。
**違反の兆候**: 使われていない抽象化レイヤー、「将来必要かも」で実装されたコード
**効果**: コードが簡潔、保守コスト削減

---

## 設計原則

### 関心の分離（Separation of Concerns）
**定義**: プログラムを異なる関心事に分割し、各部分が1つの関心事のみを扱う。
**違反の兆候**: ビジネスロジックとプレゼンテーションの混在、データアクセスとビジネスロジックの混在
**効果**: 各レイヤーが独立してテスト可能、変更の影響範囲が限定

### デメテルの法則（Law of Demeter）
**定義**: オブジェクトは直接の知り合いとのみ会話すべき。
**違反の兆候**: メソッドチェーンの乱用（`a.getB().getC().doSomething()`）、2つ以上の「.」が連続
**効果**: 疎結合な設計、内部構造の変更が容易

### Composition over Inheritance（継承よりコンポジション）
**定義**: クラスの再利用は継承よりもコンポジションを優先すべき。
**違反の兆候**: 深い継承階層（3階層以上）、継承が「is-a」でなく「has-a」
**効果**: 柔軟な機能組み合わせ、継承の制約から解放

### 純粋関数（Pure Functions）
**定義**: 関数は副作用を持たず、同じ入力に対して常に同じ出力を返すべき。
**違反の兆候**: グローバル変数の読み書き、引数の変更、I/O操作、現在時刻への依存
**効果**: テスト容易、予測可能、並行処理で安全

---

## パッケージ設計の原則

### パッケージ凝集度の原則

| 原則 | 定義 | 違反の兆候 |
|------|------|-----------|
| **REP（再利用・リリース等価）** | 再利用の単位はリリースの単位と一致すべき | パッケージ内に関連性のないクラスが混在 |
| **CRP（共通再利用）** | 一緒に再利用されるクラスを同じパッケージに | パッケージの一部の機能しか使わないクライアントが多い |
| **CCP（共通閉鎖）** | 同じ理由・タイミングで変更されるクラスを同じパッケージに | 1つの機能追加で複数パッケージを変更 |

### パッケージ結合度の原則

| 原則 | 定義 | 違反の兆候 |
|------|------|-----------|
| **ADP（非循環依存関係）** | パッケージの依存関係グラフに循環があってはならない | ビルド順序が定まらない、単独でテストできない |
| **SDP（安定依存）** | 不安定なパッケージから安定したパッケージへ依存すべき | 安定したパッケージが不安定なパッケージに依存 |
| **SAP（安定抽象化）** | パッケージの抽象度は安定度に比例すべき | 安定したパッケージに具象クラスのみ |

### 安定度と抽象度の測定

**不安定性メトリクス（I）**: `I = Ce / (Ca + Ce)`
- Ce: 外向きの依存（このパッケージが依存する他のパッケージ数）
- Ca: 内向きの依存（このパッケージに依存する他のパッケージ数）
- I = 0: 完全に安定、I = 1: 完全に不安定

**抽象度（A）**: `A = 抽象クラス・インターフェース数 / 全クラス数`
- A = 0: 完全に具象的、A = 1: 完全に抽象的

**Main Sequence距離（D）**: `D = |A + I - 1|`
- D < 0.3: 許容範囲（理想的）
- D > 0.3: 改善推奨

### パッケージ設計の適用

1. **既存コードの分析**: 依存関係グラフ可視化、循環依存検出、安定度・抽象度測定
2. **問題箇所の特定**: Main Sequenceから外れているパッケージ、循環依存箇所
3. **段階的リファクタリング**: 循環依存解消（ADP）→パッケージ分割/統合（REP, CRP, CCP）→抽象化導入（SAP）

### 検出ツール
- JavaScript/TypeScript: madge, dependency-cruiser
- Java: jdepend, ArchUnit
- Python: pydeps
- Go: go mod graph
- C#: NDepend

---

## テスト品質の原則

### FIRST原則

優れた単体テストが満たすべき5つの特性：

| 原則 | 定義 | 違反の兆候 | 改善方法 |
|------|------|-----------|---------|
| **Fast（高速）** | テストは素早く実行できるべき | テストスイート全体で数分以上かかる、外部サービスとの通信、大量データ処理 | モック/スタブの使用、テストデータの最小化、並列実行の活用 |
| **Isolated（独立）** | テストは他のテストから独立しているべき | テストの実行順序に依存、共有状態の使用、グローバル変数への依存 | 各テストで独立したセットアップ、テストごとのクリーンアップ、イミュータブルなフィクスチャ |
| **Repeatable（再現可能）** | テストは常に同じ結果を返すべき | ランダムな失敗、時刻依存、環境依存 | 時刻のモック化、固定シード、環境変数のデフォルト値設定 |
| **Self-Validating（自己検証）** | テストは明確に成功/失敗を示すべき | 手動での結果確認が必要、ログ出力の目視確認 | 明示的なassertion、意味のある失敗メッセージ |
| **Timely（適時）** | テストは適切なタイミングで書かれるべき | 実装後にテストを書く、テストなしでリリース | TDD実践、テストカバレッジの監視 |

### テスト構造パターン

#### AAA（Arrange-Act-Assert）パターン

テストコードを3つの明確なフェーズに分割：

```
# Arrange（準備）: テストに必要な前提条件とデータを設定
# Act（実行）: テスト対象のメソッドを実行
# Assert（検証）: 期待する結果が得られたことを検証
```

**メリット**:
- テストの構造が明確
- 意図が理解しやすい
- 各フェーズの責任が明確

**違反の兆候**:
- Arrange-Assert-Act-Assertのように順序が混在
- 複数回のActとAssertの繰り返し
- フェーズ間の境界が不明瞭

### テストピラミッド

効果的なテスト戦略のバランスを示すモデル：

```
        /\
       /  \      E2E Tests (少数・遅い・脆い)
      /----\
     /      \    Integration Tests (中程度)
    /--------\
   /          \  Unit Tests (多数・高速・安定)
  /------------\
```

**各層の特性**:

| レイヤー | 割合 | 速度 | コスト | スコープ | 目的 |
|---------|------|------|--------|---------|------|
| **Unit Tests（単体テスト）** | 70% | 高速（ミリ秒） | 低 | 個別の関数/クラス | ロジックの正確性、エッジケース検証 |
| **Integration Tests（統合テスト）** | 20% | 中速（秒） | 中 | コンポーネント間の統合 | インターフェースの整合性、データフロー検証 |
| **E2E Tests（E2Eテスト）** | 10% | 低速（分） | 高 | システム全体 | ユーザーシナリオ、重要パスの検証 |

**違反の兆候**（逆ピラミッド/アイスクリームコーン）:
- E2Eテストが多すぎる（実行時間が長い、不安定）
- 単体テストが少ない（バグ発見が遅い）
- 統合テストがない（統合時の問題が本番で発覚）

**アンチパターン: Ice Cream Cone（アイスクリームコーン）**
```
  /----------\  Manual Testing（手動テスト）
  \----------/
      /  \      E2E Tests（多すぎる）
     /    \
    /------\    Integration Tests（中程度）
   /--------\   Unit Tests（少なすぎる）
```

**ベストプラクティス**:
- 各層に適切なテストを配置
- 下位層でカバーできるケースは上位層でテストしない
- ピラミッドを維持しながらバランスを調整

### テスティングトロフィー（Testing Trophy）

Kent C. Doddsが提唱した、フロントエンド開発に最適化されたテスト戦略モデル：

```
      _____
     |     |    E2E Tests (少数)
    /       \
   (         )  Integration Tests (最も重視) ← ここが最大
    \       /
     \_____/    Unit Tests (適度)
       | |
     __|_|__    Static Analysis (型、Lint)
    |_______|
```

**各層の特性**:
| レイヤー | 重視度 | 目的 |
|---------|--------|------|
| Static | 高 | 型エラー、Lint違反の早期検出 |
| Unit | 中 | ユーティリティ関数、純粋ロジック |
| Integration | 最高 | コンポーネントの振る舞い検証 |
| E2E | 低 | クリティカルパスのみ |

**テストピラミッドとの使い分け**:
| 観点 | テストピラミッド | テスティングトロフィー |
|------|-----------------|----------------------|
| 最適な領域 | バックエンド、ビジネスロジック重視 | フロントエンド、UI/UX重視 |
| 重視するテスト | 単体テスト | 統合テスト |
| モックの方針 | 積極的にモック | 実装に近い形でテスト |
| 検証対象 | 内部ロジックの正確性 | ユーザー視点の振る舞い |

**トロフィーが有効なケース**:
- React/Vue/Angular等のコンポーネントベース開発
- Testing Library（@testing-library/*）を使用
- 「ユーザーが使うようにテストする」哲学
- 実装詳細よりも振る舞いを重視

**トロフィーが不向きなケース**:
- 複雑なビジネスロジック（金融計算、アルゴリズム等）
- バックエンドAPI開発
- 純粋関数やユーティリティライブラリ

### テストダブルの使い分け

| 種類 | 定義 | 用途 | 例 |
|-----|------|------|-----|
| **Dummy** | 引数を埋めるだけで使用されない | 必須引数の充足 | `new User(null, null)` |
| **Stub** | 決まった応答を返す | 間接的な入力の制御 | `getTemperature() -> 20` |
| **Spy** | 呼び出しを記録する | 間接的な出力の検証 | `emailService.sendCount` |
| **Mock** | 期待する相互作用を検証する | 振る舞いの検証 | `verify(service).send()` |
| **Fake** | 動作する簡易実装 | 複雑な依存の置き換え | インメモリDB |

**使い分けガイドライン**:
- **状態検証が可能なら**: Stub や Fake を優先（実装詳細に依存しない）
- **振る舞い検証が必要なら**: Mock を使用（ただし過度な使用は避ける）
- **簡易な実装が可能なら**: Fake を検討（最も本物に近い）

---

## 関連リファレンス

- [Code Smells](./code-smells.md) - 一般的なコードスメル
- [Test Smells](./test-smells.md) - テストコード特有のスメル
- [Refactoring Catalog](./refactoring-catalog.md) - リファクタリング技法
