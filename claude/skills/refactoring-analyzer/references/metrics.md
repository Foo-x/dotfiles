# 品質メトリクス

コード品質を定量的に評価するための指標と測定方法を提供します。

## 結合度（Coupling）

モジュール間の相互依存の度合い。結合度が低いほど、独立性が高く保守性が向上します。

### 結合度の種類（弱い順）

| 種類 | 定義 | 評価 |
|------|------|------|
| **データ結合** | プリミティブなデータのみを受け渡す | 良好（推奨） |
| **スタンプ結合** | 構造化データを渡すが一部のみ使用 | 許容可能 |
| **制御結合** | フラグで動作を制御 | 避けるべき |
| **外部結合** | 外部データフォーマット・プロトコルに依存 | 必要に応じて（抽象化で緩和） |
| **共通結合** | グローバルデータを共有 | 強く避けるべき |
| **内容結合** | 他モジュールの内部実装を直接参照・変更 | 絶対に避けるべき |

### 結合度スコア（0-10）
- 0-2: データ結合のみ（優秀）
- 3-4: スタンプ結合が少し含まれる（良好）
- 5-6: 制御結合が存在（改善推奨）
- 7-8: 共通結合が存在（要改善）
- 9-10: 内容結合が存在（緊急改善）

---

## コナーセンス（Connascence）

モジュール間の依存関係を分類・測定する概念。結合度を補完してより細かい粒度で依存関係の問題を特定できます。

### コナーセンスの3つの属性

1. **強度（Strength）**: 変更の困難さ（静的 < 動的）
2. **度合い（Degree）**: 影響される要素の数
3. **局所性（Locality）**: 依存関係の距離

### 静的コナーセンス（弱い順）

| 種類 | 定義 | 評価 |
|------|------|------|
| **名前（CoN）** | 同じ名前に依存 | 許容される（最も弱い） |
| **型（CoT）** | 同じ型に依存 | 許容可能（型安全性を提供） |
| **意味（CoM）** | 値の意味を暗黙的に共有（マジックナンバー） | 避けるべき（列挙型で改善） |
| **位置（CoP）** | 順序に依存（引数の順序） | 改善推奨（名前付き引数で改善） |
| **アルゴリズム（CoA）** | 同じアルゴリズムに依存 | 強く避けるべき（共通モジュールに集約） |

### 動的コナーセンス（強い順）

| 種類 | 定義 | 評価 |
|------|------|------|
| **実行順序（CoE）** | 実行順序に依存 | 避けるべき（依存性注入で改善） |
| **タイミング（CoTiming）** | 実行タイミングに依存（レースコンディション） | 強く避けるべき（同期化で改善） |
| **値（CoV）** | 複数の値が関連して変更される必要 | 避けるべき（トランザクションで改善） |
| **アイデンティティ（CoI）** | 同じインスタンスを参照（シングルトン） | 最も強い（最も避けるべき） |

### コナーセンス強度スコア（0-10）
- 0-2: 名前・型のみ（優秀）
- 3-4: 意味・位置あり（良好）
- 5-6: アルゴリズム・実行順序あり（改善推奨）
- 7-8: タイミング・値あり（要改善）
- 9-10: アイデンティティあり（緊急改善）

### 改善指針

1. **強度を下げる**: 動的→静的、アイデンティティ→値→実行順序→アルゴリズム→位置→意味→型→名前
2. **度合いを下げる**: 影響を受ける要素の数を減らす
3. **局所性を高める**: 依存関係を近くに配置する

---

## 凝集度（Cohesion）

### 凝集度の種類（強い順）

| 種類 | 定義 | 評価 |
|------|------|------|
| **機能的凝集** | 全要素が単一の明確な機能を実現 | 理想的（目指すべき） |
| **順次的凝集** | 出力が次の処理の入力となる一連の処理 | 良好 |
| **情報的凝集** | 同じデータ構造を操作する複数の機能 | 良好 |
| **手続き的凝集** | 特定の順序で実行される処理 | 許容可能（改善の余地） |
| **時間的凝集** | 特定のタイミングで実行される処理 | 避けるべき |
| **論理的凝集** | 論理的に似ているが関連性のない処理 | 避けるべき |
| **偶発的凝集** | 関連性のない要素が偶然グループ化 | 絶対に避けるべき |

### LCOM（Lack of Cohesion of Methods）

```
LCOM = 1 - (sum(MF) / (M * F))
M: メソッド数、F: フィールド数、MF: 各メソッドが使用するフィールド数の合計
```

**判定基準**:
- LCOM < 0.3: 高凝集（優秀）
- 0.3 ≤ LCOM < 0.5: 中凝集（許容可能）
- 0.5 ≤ LCOM < 0.7: 低凝集（改善推奨）
- LCOM ≥ 0.7: 非常に低凝集（要分割）

---

## 循環的複雑度（Cyclomatic Complexity）

制御フローの複雑さを測定する指標。独立した実行パスの数を表します。

### 計算方法

```
CC = E - N + 2P
E: エッジ数、N: ノード数、P: 連結成分数（通常は1）

簡易計算: CC = 判定ポイント数 + 1
判定ポイント: if, while, for, case, &&, ||, ?:
```

### 評価基準

| CC値 | 評価 | リスク | 推奨アクション |
|------|------|--------|----------------|
| 1-10 | 低複雑度 | 低 | 問題なし |
| 11-20 | 中複雑度 | 中 | レビュー推奨 |
| 21-50 | 高複雑度 | 高 | リファクタリング推奨 |
| 51+ | 極めて高い | 極めて高い | 即座にリファクタリング |

---

## 認知的複雑度（Cognitive Complexity）

コードの理解しやすさを測定する指標。人間がコードを読むときの精神的負荷を表します。

### 計算方法

以下の構造にペナルティを加算:
1. **+1**: 制御フロー構造（if, else if, switch, for, while, catch）
2. **+1**: ネストごと（ネストが深いほど増加）
3. **+1**: 論理演算子の連鎖（&&, ||）
4. **+0**: else（複雑度を増やさない）

### 評価基準

| 値 | 評価 | 推奨アクション |
|----|------|----------------|
| 0-5 | 低 | 問題なし |
| 6-10 | 中 | レビュー推奨 |
| 11-15 | 高 | リファクタリング推奨 |
| 16+ | 極めて高い | 即座にリファクタリング |

---

## その他の有用なメトリクス

### ネストの深さ（Nesting Depth）
- 推奨値: 最大3階層まで
- 4階層以上は要リファクタリング
- 改善方法: 早期リターン、メソッド抽出、Guard Clauses

### 行数（Lines of Code）
- 関数: 20-50行が理想
- クラス: 200-500行が理想
- ファイル: 500行以下が理想

### コメント密度
```
コメント密度 = (コメント行数 / SLOC) * 100
```
- 推奨値: 10-30%
- 0%: コメント不足
- 50%以上: コードが複雑すぎる可能性

---

## 品質スコア総合評価（0-100）

```
品質スコア = 40 * (1 - 結合度正規化) +
             30 * 凝集度正規化 +
             20 * (1 - CC正規化) +
             10 * (1 - 認知的複雑度正規化)
```

**評価基準**:
- 80-100: 優秀
- 60-79: 良好
- 40-59: 改善推奨
- 0-39: 要改善
