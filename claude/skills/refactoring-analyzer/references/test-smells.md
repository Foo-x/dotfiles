# Test Code Smells Catalog

テストコードに特有のコードスメルのカタログ。xUnit Test Patternsをベースに分類。

---

## Test Bloaters（テストの肥大化）

### Eager Test
**症状**: 1つのテストメソッドが複数の関心事を検証している。

**問題点**:
- テストが失敗した時に原因の特定が困難
- テストの意図が不明瞭
- 部分的な失敗を検出できない

**検出方法**:
- 1つのテストメソッドに複数のassertionが異なる関心事を検証
- テストメソッド名が「And」で複数の動作を列挙
- SetUpで複数の異なるシナリオを準備

**リファクタリング**:
- 関心事ごとにテストメソッドを分割
- 各テストは1つの振る舞いのみを検証

---

### Obscure Test
**症状**: テストの意図や挙動が理解しにくい。

**問題点**:
- テストの保守コストが高い
- バグ修正時にテストの意図を推測する必要がある
- 新規開発者がテストから仕様を理解できない

**検出方法**:
- マジックナンバーやマジックストリングが多数
- テストデータの意図が不明
- Given-When-Thenの構造が不明瞭
- 複雑な前提条件やセットアップロジック

**リファクタリング**:
- 意味のある定数や変数名を使用
- テストデータビルダーパターンの導入
- AAA（Arrange-Act-Assert）パターンの明確化
- コメントではなくコードで意図を表現

---

### Long Test
**症状**: テストメソッドが長すぎて読みにくい。

**問題点**:
- 可読性の低下
- メンテナンスコストの増加
- テストの実行速度が遅い可能性

**検出方法**:
- 50行以上のテストメソッド
- 複雑なセットアップロジック
- 多段階の操作フロー

**リファクタリング**:
- ヘルパーメソッドへの抽出
- テストデータビルダーの活用
- 複雑なシナリオは複数のテストに分割

---

## Test Logic Smells（テストロジックの問題）

### Conditional Test Logic
**症状**: テストコード内にif文やswitch文などの条件分岐がある。

**問題点**:
- テストの実行パスが不明確
- テスト自体にバグが混入する可能性
- すべてのパスが実行されているか不明

**検出方法**:
- if/else, switch/case文の存在
- 三項演算子の使用
- ループ内での条件分岐

**リファクタリング**:
- パラメータ化テストへの変換
- テストケースを分割
- 条件分岐をセットアップフェーズに移動

---

### Assertion Roulette
**症状**: 複数のassertionがあり、どれが失敗したか特定しにくい。

**問題点**:
- テスト失敗時のデバッグコストが高い
- 失敗メッセージが不明瞭
- 最初の失敗でテストが停止し、後続の問題を検出できない

**検出方法**:
- 説明メッセージのない複数のassertion
- 同じオブジェクトに対する複数の検証
- assertionの失敗時に文脈が失われる

**リファクタリング**:
- 各assertionにカスタムメッセージを追加
- 複合assertionの使用（assertAll, expectなど）
- 検証対象ごとにテストを分割

---

### Sensitive Equality
**症状**: 等価性の検証が過度に厳密で、無関係な変更でテストが壊れる。

**問題点**:
- テストの脆弱性（Fragile Test）
- リファクタリングの妨げ
- 本質的でない変更でテストが失敗

**検出方法**:
- オブジェクト全体の完全一致を検証
- 文字列の完全一致（空白やフォーマット含む）
- タイムスタンプなど変動する値の厳密な比較

**リファクタリング**:
- 重要なフィールドのみを検証
- 部分一致やパターンマッチングの使用
- カスタムマッチャーの実装
- Approximate Equalityの使用（浮動小数点など）

---

## Test Isolation Smells（テスト分離の問題）

### Shared State
**症状**: テスト間で状態を共有し、実行順序に依存する。

**問題点**:
- テストの独立性が損なわれる
- 並列実行ができない
- テストの失敗が他のテストに波及

**検出方法**:
- クラスフィールドやスタティック変数の変更
- @BeforeAllでの可変状態の初期化
- テストの実行順序を変えると結果が変わる
- グローバルシングルトンの使用

**リファクタリング**:
- 各テストで独立した状態を準備（@BeforeEach）
- テスト間でのデータ共有を排除
- イミュータブルなテストフィクスチャの使用
- データベースのトランザクションロールバック

---

### Test Run War
**症状**: 複数のテストが同じリソース（ファイル、ポート、DB）を奪い合う。

**問題点**:
- 並列実行時のランダムな失敗
- 環境依存のテスト
- CIでの不安定性

**検出方法**:
- 固定ポート番号の使用
- 固定ファイル名の使用
- 共有データベースの同時アクセス
- 並列実行でテストが不安定

**リファクタリング**:
- ユニークなリソース識別子の生成
- テンポラリファイル・ディレクトリの使用
- ポート番号の動的割り当て
- テスト専用の独立したリソースプール

---

### Resource Optimism
**症状**: 外部リソースの存在を仮定し、検証やクリーンアップを行わない。

**問題点**:
- テスト環境への依存
- 他の開発者の環境でテストが失敗
- CI環境での不安定性

**検出方法**:
- ファイルやディレクトリの存在チェックがない
- 外部サービスの可用性を仮定
- ハードコードされたパスやURL
- 環境変数への暗黙的な依存

**リファクタリング**:
- リソースの存在確認と適切なエラーハンドリング
- テストフィクスチャでリソースを準備・クリーンアップ
- モック/スタブによる外部依存の排除
- 環境変数のデフォルト値設定

---

## Test Maintainability Smells（テスト保守性の問題）

### Test Code Duplication
**症状**: テストコード間で重複したロジックやセットアップが存在する。

**問題点**:
- 保守コストの増加
- 変更時の修正漏れ
- 一貫性の欠如

**検出方法**:
- 同じセットアップコードの繰り返し
- 類似したassertionパターン
- テストデータ生成の重複

**リファクタリング**:
- テストヘルパーメソッドへの抽出
- テストデータビルダーの導入
- カスタムマッチャー/アサーションの実装
- @BeforeEachでの共通セットアップ
- パラメータ化テストの活用

---

### Hard-Coded Test Data
**症状**: テストデータがハードコードされ、柔軟性がない。

**問題点**:
- テストの脆弱性
- データの意図が不明
- 境界値テストの不足

**検出方法**:
- マジックナンバー/マジックストリングの多用
- テストデータの意味が不明
- データ生成ロジックの重複

**リファクタリング**:
- 意味のある定数への抽出
- テストデータビルダーの使用
- ファクトリーメソッドの導入
- データ駆動テスト（CSV、JSONなど）

---

### Mystery Guest
**症状**: 外部ファイルやデータベースからテストデータを読み込み、テストが理解しにくい。

**問題点**:
- テストの自己文書化が損なわれる
- データの変更でテストが予期せず失敗
- テストの独立性が損なわれる

**検出方法**:
- 外部ファイル（JSON、XML、CSVなど）からのデータ読み込み
- テストフィクスチャファイルへの依存
- データベースのマスターデータへの依存

**リファクタリング**:
- インラインでテストデータを定義
- テストコード内でデータを構築
- 必要最小限のデータのみを使用
- データビルダーで意図を明確化

---

## Test Double Smells（テストダブルの問題）

### Mock Overuse
**症状**: 過度にモックを使用し、テストが実装詳細に依存する。

**問題点**:
- リファクタリング耐性の低下
- テストが実装の変更で壊れやすい
- 本当のバグを検出できない

**検出方法**:
- ほぼすべての依存関係をモック化
- モックの振る舞い検証が詳細すぎる
- メソッド呼び出し順序の厳密な検証
- プライベートメソッドのモック

**リファクタリング**:
- 実オブジェクトの使用を検討
- スタブで十分な場合はモックを避ける
- 状態ベースの検証を優先
- インテグレーションテストへの移行

---

### Leaky Mock
**症状**: モックの設定が不完全で、テストが不安定または誤った成功を示す。

**問題点**:
- 偽陽性（False Positive）
- テストが実際の動作を検証していない
- 実装バグの見逃し

**検出方法**:
- デフォルト値に依存したモック設定
- 呼び出されないはずのメソッドの検証欠如
- 例外ケースのモック設定漏れ
- モックの戻り値が現実的でない

**リファクタリング**:
- 厳格なモック（Strict Mock）の使用
- すべての相互作用を明示的に定義
- モックの検証を追加（verify）
- 現実的なテストデータの使用

---

## 参考文献

- **xUnit Test Patterns** - Gerard Meszaros
  - テストスメルの包括的なカタログ
  - https://xunitpatterns.com

- **Refactoring Test Code** - Arie van Deursen et al.
  - テストコード特有のリファクタリング手法

- **Growing Object-Oriented Software, Guided by Tests** - Steve Freeman & Nat Pryce
  - モックの適切な使用方法

---

## 関連リファレンス

- [Refactoring Catalog](./refactoring-catalog.md) - 一般的なリファクタリング技法
- [Principles](./principles.md) - テスト品質の原則（FIRST原則など）
