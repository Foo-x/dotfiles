# コードスメルカタログ

## Bloaters（肥大化）

### Long Method（長すぎるメソッド）
**定義**: メソッドやファンクションが長すぎる。
**基準**: 50行以上、スクロール必要、複数の責任

### Large Class（大きすぎるクラス）
**定義**: 1つのクラスが多すぎる責任を持つ。
**基準**: 500行以上、20個以上のフィールド、30個以上のメソッド

### Long Parameter List（長すぎる引数リスト）
**定義**: メソッドの引数が多すぎる。
**基準**: 4個以上の引数、同じ型の引数が連続

### Primitive Obsession（プリミティブ型への執着）
**定義**: ドメイン概念を表現するのにプリミティブ型を使用。
**基準**: 電話番号・郵便番号が単なるstring、金額が単なるnumber

### Data Clumps（データの群れ）
**定義**: 常に一緒に現れるデータのグループ。
**基準**: 同じ引数セットの繰り返し、同じフィールドセットの繰り返し、3つ以上のデータが常にセット

## Object-Orientation Abusers（オブジェクト指向の濫用）

### Switch Statements（switch文の乱用）
**定義**: 型コードに基づく複雑なswitch文やif-else連鎖。
**基準**: 同じ型チェックが複数箇所、switch文が3箇所以上で繰り返し

### Temporary Field（一時的なフィールド）
**定義**: 特定の状況でのみ値が設定されるフィールド。
**基準**: nullや空値が多い、特定メソッド実行時のみ使用

### Refused Bequest（親クラスの拒絶）
**定義**: サブクラスが親クラスのメソッドの一部しか使用しない。
**基準**: 親メソッドをオーバーライドして例外スロー、継承が「is-a」でなく「has-a」

## Change Preventers（変更の妨害者）

### Divergent Change（発散的変更）
**定義**: 1つのクラスが異なる理由で頻繁に変更される。
**基準**: 複数の異なる理由で変更、異なるチームが同じクラスを修正

### Shotgun Surgery（散弾銃手術）
**定義**: 1つの変更が複数のクラスに影響する。
**基準**: 1つの機能追加で10個以上のファイル修正、関連コードが分散

## Dispensables（不要なもの）

### Dead Code（デッドコード）
**定義**: 使用されていないコード。
**基準**: 呼び出されていないメソッド、参照されていない変数、到達不可能なブロック

### Duplicate Code（重複コード）
**定義**: 同じまたは類似したコードが複数箇所に存在。
**基準**: 同一コードブロックが2箇所以上、コピー&ペーストの痕跡

### Speculative Generality（投機的一般化）
**定義**: 将来必要になるかもという理由だけで作られた抽象化。
**基準**: 使用されていない抽象化、単一実装のインターフェース

## Couplers（結合の問題）

### Feature Envy（機能への羨望）
**定義**: メソッドが自分のクラスより他クラスのデータに興味を持つ。
**基準**: 他クラスのgetterを多用、他クラスのメソッドを頻繁に呼び出し

### Inappropriate Intimacy（不適切な関係）
**定義**: 2つのクラスが互いの内部実装に深く依存。
**基準**: 双方向依存、protectedメンバーへの頻繁なアクセス

### Message Chains（メッセージチェーン）
**定義**: 長い呼び出しチェーン（Law of Demeter違反）。
**基準**: `a.b().c().d()`のような連鎖、3つ以上の「.」が連続

### Middle Man（仲介者）
**定義**: クラスが単に他クラスへの委譲しかしていない。
**基準**: メソッドの大部分が委譲のみ、独自ロジックがほとんどない

## Encapsulation Breakers（カプセル化の破壊）

### Excessive Exposure（過度な公開）
**定義**: 不必要にpublicにしているフィールドやメソッド。
**基準**: 外部から使用されないpublicメンバー、内部実装の詳細を公開

### Missing Access Modifier（アクセス修飾子の欠如）
**定義**: 言語のデフォルトアクセスレベルに依存し、明示的な修飾子がない。
**基準**: 修飾子なしのメンバー、意図が不明確な可視性

### Leaky Abstraction（漏洩する抽象）
**定義**: 内部実装の詳細が公開APIを通じて漏れている。
**基準**: 内部データ構造を直接返すpublicメソッド、可変オブジェクトをそのまま公開
