#!/usr/bin/env python3
"""
è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
CVE/NVD/GitHub Advisory Databaseã¨ã®é€£æº
"""

import os
import sys
import json
import re
from typing import Dict, List, Optional
from pathlib import Path


class VulnerabilityLookup:
    """è„†å¼±æ€§æ¤œç´¢ã‚¯ãƒ©ã‚¹"""

    def __init__(self):
        self.cache_dir = Path.home() / '.cache' / 'security-review-generator'
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def search_cve(self, package_name: str, version: Optional[str] = None) -> List[Dict]:
        """CVEæ¤œç´¢

        Args:
            package_name: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å
            version: ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆçœç•¥å¯ï¼‰

        Returns:
            CVEãƒªã‚¹ãƒˆ
        """
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€NVD APIã‚„GitHub Advisory APIã‚’ä½¿ç”¨
        # ã“ã“ã§ã¯ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™

        print(f"Searching CVE for {package_name}" + (f" version {version}" if version else ""),
              file=sys.stderr)

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        cache_key = f"{package_name}_{version or 'any'}.json"
        cache_file = self.cache_dir / cache_key

        if cache_file.exists():
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                pass

        # æ—¢çŸ¥ã®è„†å¼±æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®Ÿéš›ã«ã¯APIå‘¼ã³å‡ºã—ï¼‰
        vulnerabilities = self._mock_vulnerability_data(package_name, version)

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
        try:
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(vulnerabilities, f, indent=2)
        except Exception as e:
            print(f"Warning: Failed to cache results: {e}", file=sys.stderr)

        return vulnerabilities

    def _mock_vulnerability_data(self, package_name: str, version: Optional[str]) -> List[Dict]:
        """ãƒ¢ãƒƒã‚¯è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯APIå‘¼ã³å‡ºã—ï¼‰"""
        # ä¸€èˆ¬çš„ãªè„†å¼±æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³
        common_vulns = {
            'express': [
                {
                    'cve_id': 'CVE-2024-XXXX',
                    'severity': 'HIGH',
                    'cvss_score': 7.5,
                    'description': 'Potential prototype pollution vulnerability',
                    'affected_versions': '< 4.19.2',
                    'fixed_version': '4.19.2',
                    'references': ['https://nvd.nist.gov/vuln/detail/CVE-2024-XXXX']
                }
            ],
            'django': [
                {
                    'cve_id': 'CVE-2024-YYYY',
                    'severity': 'MEDIUM',
                    'cvss_score': 6.1,
                    'description': 'SQL injection vulnerability in ORM',
                    'affected_versions': '< 4.2.11',
                    'fixed_version': '4.2.11',
                    'references': ['https://www.djangoproject.com/weblog/']
                }
            ],
            'react': [
                {
                    'cve_id': 'CVE-2024-ZZZZ',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.4,
                    'description': 'XSS vulnerability in rendering',
                    'affected_versions': '< 18.2.0',
                    'fixed_version': '18.2.0',
                    'references': ['https://github.com/facebook/react/security/advisories']
                }
            ],
        }

        pkg_lower = package_name.lower()
        for key, vulns in common_vulns.items():
            if key in pkg_lower:
                return vulns

        return []

    def search_github_advisory(self, ecosystem: str, package_name: str) -> List[Dict]:
        """GitHub Advisory Databaseæ¤œç´¢

        Args:
            ecosystem: ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ  (npm, pip, maven, etc.)
            package_name: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å

        Returns:
            Advisory ãƒªã‚¹ãƒˆ
        """
        print(f"Searching GitHub Advisory for {ecosystem}:{package_name}", file=sys.stderr)

        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub GraphQL APIã‚’ä½¿ç”¨
        # https://docs.github.com/en/graphql/reference/objects#securityadvisory

        return []

    def batch_search(self, dependencies: Dict[str, List[str]]) -> Dict[str, List[Dict]]:
        """ä¾å­˜é–¢ä¿‚ã®ä¸€æ‹¬æ¤œç´¢

        Args:
            dependencies: {package_manager: [package_names]}

        Returns:
            {package_name: [vulnerabilities]}
        """
        results = {}

        ecosystem_map = {
            'npm': 'npm',
            'pip': 'pip',
            'maven': 'maven',
            'go': 'go',
            'cargo': 'cargo',
            'composer': 'composer',
            'rubygems': 'rubygems',
        }

        for pkg_manager, packages in dependencies.items():
            ecosystem = ecosystem_map.get(pkg_manager.lower(), 'unknown')

            for package in packages:
                # ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’åˆ†é›¢
                match = re.match(r'([^=<>~]+)', package)
                if match:
                    pkg_name = match.group(1).strip()
                    vulns = self.search_cve(pkg_name)

                    if vulns:
                        results[pkg_name] = vulns

        return results

    def generate_vulnerability_report(self, vulnerabilities: Dict[str, List[Dict]]) -> str:
        """è„†å¼±æ€§ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

        Args:
            vulnerabilities: {package_name: [vulnerabilities]}

        Returns:
            Markdownå½¢å¼ã®ãƒ¬ãƒãƒ¼ãƒˆ
        """
        if not vulnerabilities:
            return "## ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§\n\nâœ… æ—¢çŸ¥ã®è„†å¼±æ€§ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n"

        lines = ["## ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§\n"]

        # é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'INFO': 4}

        all_vulns = []
        for pkg_name, vulns in vulnerabilities.items():
            for vuln in vulns:
                vuln['package_name'] = pkg_name
                all_vulns.append(vuln)

        all_vulns.sort(key=lambda v: severity_order.get(v.get('severity', 'INFO'), 5))

        for vuln in all_vulns:
            pkg_name = vuln['package_name']
            cve_id = vuln.get('cve_id', 'N/A')
            severity = vuln.get('severity', 'UNKNOWN')
            cvss_score = vuln.get('cvss_score', 0.0)
            description = vuln.get('description', 'No description')
            affected = vuln.get('affected_versions', 'Unknown')
            fixed = vuln.get('fixed_version', 'Not fixed')

            # é‡è¦åº¦ã®çµµæ–‡å­—
            emoji = {
                'CRITICAL': 'ğŸ”´',
                'HIGH': 'ğŸŸ ',
                'MEDIUM': 'ğŸŸ¡',
                'LOW': 'ğŸŸ¢',
                'INFO': 'â„¹ï¸',
            }.get(severity, 'âšª')

            lines.append(f"### {emoji} {pkg_name}: {cve_id}\n")
            lines.append(f"**é‡è¦åº¦:** {severity} (CVSS: {cvss_score})\n")
            lines.append(f"**èª¬æ˜:** {description}\n")
            lines.append(f"**å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³:** {affected}\n")
            lines.append(f"**ä¿®æ­£ãƒãƒ¼ã‚¸ãƒ§ãƒ³:** {fixed}\n")

            if 'references' in vuln and vuln['references']:
                lines.append("\n**å‚è€ƒæƒ…å ±:**\n")
                for ref in vuln['references']:
                    lines.append(f"- {ref}\n")

            lines.append("\n---\n\n")

        return ''.join(lines)


def main():
    """ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    if len(sys.argv) < 2:
        print("Usage: vulnerability_lookup.py <command> [args]")
        print("\nCommands:")
        print("  search <package_name> [version]  - Search CVE for a package")
        print("  batch <dependencies_json>        - Batch search from dependencies JSON")
        sys.exit(1)

    command = sys.argv[1]
    lookup = VulnerabilityLookup()

    if command == 'search':
        if len(sys.argv) < 3:
            print("Error: package_name required")
            sys.exit(1)

        package_name = sys.argv[2]
        version = sys.argv[3] if len(sys.argv) > 3 else None

        results = lookup.search_cve(package_name, version)
        print(json.dumps(results, indent=2, ensure_ascii=False))

    elif command == 'batch':
        if len(sys.argv) < 3:
            print("Error: dependencies_json required")
            sys.exit(1)

        try:
            # JSONæ–‡å­—åˆ—ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            if os.path.exists(sys.argv[2]):
                with open(sys.argv[2], 'r', encoding='utf-8') as f:
                    dependencies = json.load(f)
            else:
                dependencies = json.loads(sys.argv[2])

            results = lookup.batch_search(dependencies)

            # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
            report = lookup.generate_vulnerability_report(results)
            print(report)

        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    else:
        print(f"Error: Unknown command '{command}'")
        sys.exit(1)


if __name__ == '__main__':
    main()
