# 理論的フレームワーク — テストケース生成のための基礎

> 出典: 「要求定義・仕様記述・設計・検証の手引き」（CSP安定失敗モデル・状態機械・トレース理論に基づく枠組み）

## 目次

1. [基礎概念](#基礎概念)
2. [トレースとトレース集合](#トレースとトレース集合)
3. [安定状態と失敗](#安定状態と失敗)
4. [機能要求の3性質](#機能要求の3性質)
5. [状態機械の記法](#状態機械の記法)
6. [テストケースの定義](#テストケースの定義)
7. [成果物間の推移律](#成果物間の推移律)

---

## 基礎概念

### イベント

**イベント**とは状態遷移の引き金。主な種類:

| 種類 | 例 |
|-----|---|
| UIイベント | クリック、ホバー、スクロール |
| 時間経過 | タイムアウト |
| 通信 | サーバー間・DB含む |
| **内部イベント τ** | 外から観測・制御できない隠れたイベント |

τ（タウ）は外部から観測できないため、トレースからは取り除かれる。

### 同期イベント

複数の状態機械が1つのイベントで同時に状態遷移するとき、そのイベントを**同期イベント**という。

- τは同期イベントにできない
- 典型例: クライアント↔サーバー間の通信、ユーザー↔システム間のUI操作

### 並行合成

2つの状態機械 P, Q と同期イベント集合 A から1つの大きな状態機械 P ‖_A Q を作る操作。

| ケース | 動作 |
|-------|------|
| 両方が同期イベントで遷移できる | くっつけて遷移（両方同時に状態が変わる） |
| 片方が同期イベントで遷移できない | 合成後も遷移不可（同期の制約） |
| 非同期イベント | 片方だけで遷移可能（もう一方は待機） |

並行合成の結果: 合成後の初期状態は `(S_P0, S_Q0)`。

---

## トレースとトレース集合

### トレース

**トレース**とは初期状態から連続的に遷移可能なイベントの列から τ を取り除いたもの。

- 空トレース ε も有効なトレース（初期状態での観測）
- 表記: `⟨e1, e2, e3⟩` または `e1 → e2 → e3`

### トレース集合

状態機械が出せる**すべてのトレース**を集めた集合 `traces(P)`。

**重要な性質（前置閉包）:** トレース集合は前置閉包を持つ。つまり `⟨e1, e2⟩ ∈ traces(P)` なら `⟨e1⟩ ∈ traces(P)` かつ `ε ∈ traces(P)`。

---

## 安定状態と失敗

### 安定状態

**安定状態**とは τ で遷移できない状態のこと。安定状態では、外部からのイベントを「受け入れる」か「拒否する」かが確定する。

### 失敗

**失敗**とは以下の組:
```
(s, X)
```
- `s`: 安定状態に至るトレース
- `X`: その安定状態で**拒否されるイベントの集合**（拒否集合）

**失敗集合** `failures(P)`: すべての失敗を集めた集合。

**活用:** 失敗集合はテスト設計において拒否テストケースの候補を直接提供する。「トレース `s` を実行した後にイベント `e ∈ X` を送ると拒否される」という具体的なテストケースが得られる。

---

## 機能要求の3性質

**機能要求**とはトレース集合の満たすべき性質の定義。

| 性質 | 形式的意味 | テストへの対応 |
|-----|----------|--------------|
| **活性** | 「Xが起こるといつかYが起こる」。∀s ∈ traces(P): sがXを含むなら、sをある拡張 s' ∈ traces(P) でYを含む | Y到達を確認するA-テストケース |
| **到達可能性** | トレース集合の中に条件を満たすトレースが存在する（活性だけでは不十分） | 条件を満たすA-テストケース |
| **安全性** | 悪いことが決して起こらない。特定のイベントが発生しない/特定の順序で起こらない | 違反を試みるR-テストケース |

> **ポイント**: 機能要求の時点では、言及されていないトレースがどうなっているかは不明。仕様（トレース集合・失敗集合）で初めて完全な振る舞いが定まる。

---

## 状態機械の記法

### 基本要素

```
状態機械 M = (S, S0, Σ, δ, V, V0)
```
- `S`: 状態集合
- `S0`: 初期状態
- `Σ`: イベント集合（τを含む）
- `δ`: 遷移関係
- `V`: 状態変数集合
- `V0`: 状態変数の初期値

### 遷移の記法

```
source --[event [guard] / postcondition]--> target
```

| 要素 | 説明 | 例 |
|-----|------|---|
| **event** | トリガーとなるイベント | `coin`, `button_A` |
| **guard** | 遷移できる条件（真なら省略可） | `[total >= price_A]` |
| **postcondition** | 遷移後の状態変数の関係（`'`は遷移後の値） | `/ total' = 0` |

### 状態変数の例

```
状態変数: total: Int = 0, stock_A: Int = 10
遷移: idle --[coin(v)] / total' = total + v --> waiting
遷移: waiting --[button_A] [total >= price_A and stock_A > 0] / total' = 0, stock_A' = stock_A - 1 --> dispensing
```

---

## テストケースの定義

**テストケース**とは**トレースと期待結果の組**:

```
(trace, expected_result)
```

| サンプリング元 | 期待結果 |
|--------------|---------|
| `traces(P)` に含まれるトレース（集合内） | **受理** |
| `traces(P)` に含まれないトレース（集合外） | **拒否** |

### なぜ2種類のテストが必要か

- **受理テスト（活性・到達可能性の検証）**: システムが「やるべきこと」をやれることを確認。トレース集合は巨大なため、リスクベースサンプリングで代表例を選ぶ。
- **拒否テスト（安全性の検証）**: システムが「やってはいけないこと」をしないことを確認。トレース集合外のトレースが実際に拒否されることを検証する。

---

## 成果物間の推移律

```
機能要求
  ↓（活性・到達可能性・安全性で制約）
トップレベル仕様（トレース集合・失敗集合）
  ↓（トレース集合と失敗集合で制約）
コンポーネント仕様（設計）
  ↓（並行合成でトップレベル仕様を充足確認）
実装
```

**精緻化（Refinement）の条件:**
下位の成果物 Q が上位の P を精緻化する（P を満たす）:
- `traces(Q) ⊆ traces(P)`
- `failures(Q) ⊆ failures(P)`

**推移律:** `R ≤ Q ≤ P` ならば `R ≤ P`。コンポーネントがそれぞれの仕様を満たせば、並行合成後の実装もトップレベル仕様を満たす。

**テストへの含意:** テストが上位の仕様（機能要求・トップレベル仕様）に基づいて設計されていれば、そのテストは下位の実装にも適用可能。
