export HISTSIZE=100000
export HISTFILESIZE=100000
export HISTTIMEFORMAT='%F %T '
export HISTCONTROL=ignorespace  # not save commands that space-beginned and duplicated to history
export HISTIGNORE='?:??:???:history:cd*:exit:clear'

if [ "$TMUX" ]; then
    export PATH=$(echo "$PATH" | sed -E 's#(.*):?.+.vscode-server[^:]+:#\1#')
fi

export EDITOR='nvim -p'

export PAGER='more'
if type less &> /dev/null; then
  export PAGER='less'
  export LESS='RFMi'
  export LESS_TERMCAP_mb=$'\E[1;31m'   # Begins blinking.
  export LESS_TERMCAP_md=$'\E[36m'     # Begins bold.
  export LESS_TERMCAP_so=$'\E[47;30m'  # Begins standout-mode.
  export LESS_TERMCAP_us=$'\E[1;36m'   # Begins underline.
  export LESS_TERMCAP_me=$'\E[0m'      # Ends mode.
  export LESS_TERMCAP_se=$'\E[0m'      # Ends standout-mode.
  export LESS_TERMCAP_ue=$'\E[0m'      # Ends underline.
fi

if type diff-highlight &> /dev/null; then
  export GIT_PAGER='diff-highlight | ${PAGER}'
fi

export SIMPLE_BACKUP_SUFFIX=.`date +%Y%m%d_%H%M%S`

[[ "${WSL_DISTRO_NAME}" ]] && export BROWSER=wslview

export LANG=C
LOCALE_LIST="$(locale -a)"
if [[ "${LOCALE_LIST}" == *C.UTF-8* ]]; then
  export LC_CTYPE='C.UTF-8'
fi

stty start ''
stty stop ''

export FZF_DEFAULT_OPTS='--reverse --cycle --bind "change:top" -0'
export FZF_DEFAULT_COMMAND='grep -rl "" --exclude-dir=.git --exclude-dir=node_modules'

export ENHANCD_FILTER=fzf
export ENHANCD_ENABLE_SINGLE_DOT=false
export ENHANCD_ARG_DOUBLE_DOT=...

# exec commands after each commands
function dispatch_prompt_command() {
  local f
  for f in ${!PROMPT_COMMAND_*}; do
    eval "${!f}"
  done
}
export PROMPT_COMMAND='dispatch_prompt_command'

function __dedup_history() {
  history -a

  cmd='
import operator
import re
from os import getenv
from os.path import expanduser
from typing import Dict, List, Optional

timestamp_pattern = re.compile("^#\d+$")
history_path = expanduser(getenv("HISTFILE", "~/.bash_history"))


def load_history() -> List[str]:
    with open(history_path) as f:
        return f.read().splitlines()


def extract_last_command(history: List[str]) -> Optional[str]:
    try:
        last_timestamp_line_num = next(
            i
            for i, line in reversed(list(enumerate(history)))
            if timestamp_pattern.fullmatch(line)
        )
        return "\n".join(history[last_timestamp_line_num + 1 :])
    except:
        return


def deduplicate_history(history: List[str]) -> List[str]:
    commands: Dict[str, str] = {}
    command = ""
    timestamp = ""
    for line in history:
        if timestamp_pattern.fullmatch(line):
            if command:
                commands[command.strip()] = timestamp
                command = ""
            timestamp = line
        else:
            command += line + "\n"

    if command:
        commands[command.strip()] = timestamp

    result: List[str] = []
    sorted_commands = sorted(commands.items(), key=operator.itemgetter(1))
    for command, timestamp in sorted_commands:
        result.append(timestamp)
        result.append(command)

    return result


def update_history(new_history: List[str]):
    out = "\n".join(new_history) + "\n"
    with open(history_path, "w") as f:
        f.write(out)


def main():
    history = load_history()
    if len(history) <= 1:
        return

    last_command = extract_last_command(history)
    if not last_command:
        return

    new_history = deduplicate_history(history)
    update_history(new_history)


main()
'

  if type python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi

  history -c
  history -r
}

if type python &> /dev/null || type python3 &> /dev/null; then
  export PROMPT_COMMAND_HISTSAVE='__dedup_history'
fi

function lsgit() {
  ls -A
  if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = "true" ] ; then
    echo
    git status -sb
  fi
}

function lsgit_cd() {
  if [ "${LSGIT_DIR:-${PWD}}" != "${PWD}" ]; then
    lsgit
  fi
  LSGIT_DIR=${PWD}
}
export PROMPT_COMMAND_LSGIT_CD='lsgit_cd'

trap '((cmdcnt++))' DEBUG
function lsgit_enter() {
  if [ $((lsgit_enter_cnt + 1)) = ${cmdcnt} ]; then
    lsgit
  fi

  lsgit_enter_cnt=${cmdcnt}
}
export PROMPT_COMMAND_LSGIT_ENTER='lsgit_enter'

# prompt
SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE:-$0}); pwd)

if [[ -n "${VIMRUNTIME}" ]]; then
    VIMLABEL="! "
    export PS1="${VIMLABEL}${PS1}"
fi

. ${SCRIPT_DIR}/git-prompt.sh

# PS1
## 24bit habamax
#__red='38;2;175;135;175'
#__green='38;2;135;175;135'
#__yellow='38;2;175;175;135'
#__blue='38;2;135;175;175'

## 24bit PCCS bright
#__red='38;2;208;103;142'
#__green='38;2;65;184;121'
#__yellow='38;2;255;173;54'
#__blue='38;2;41;129;192'

## 24bit PCCS soft
#__red='38;2;180;120;139'
#__green='38;2;118;177;138'
#__yellow='38;2;219;166;107'
#__blue='38;2;93;126;160'

## 24bit PCCS light+
__red='38;2;217;142;165'
__green='38;2;133;206;158'
__yellow='38;2;255;190;113'
__blue='38;2;108;154;197'

## 4bit lighter
#__red='91'
#__green='92'
#__yellow='93'
#__blue='94'

## 4bit darker
#__red='31'
#__green='32'
#__yellow='33'
#__blue='34'

export PS1='\n${VIMLABEL}\[\e[${__green}m\]\u \[\e[${__yellow}m\]&:\j \[\e[${__blue}m\]\w\[\e[${__red}m\]$(__git_ps1)\n$(if [[ $? == "0" ]]; then printf "\[\e[${__green}m\]:)"; else printf "\[\e[${__red}m\]:("; fi)\[\e[00m\] '

GIT_PS1_SHOWDIRTYSTATE=1  # show if there are changed files '*' for unstaged and '+' for staged
GIT_PS1_SHOWSTASHSTATE=1  # show '$' if something is stashed
GIT_PS1_SHOWUNTRACKEDFILES=1  # show '%' if there are untracked files
GIT_PS1_SHOWUPSTREAM=auto  # show diff from upstream
GIT_PS1_DESCRIBE_STYLE=branch  # show detached HEAD as relative to branch
GIT_PS1_SHOWCONFLICTSTATE=yes  # show '|CONFLICT' if there are conflicts
