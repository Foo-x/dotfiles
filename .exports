export HISTSIZE=100000
export HISTFILESIZE=100000
export HISTTIMEFORMAT='%F %T '
export HISTCONTROL=ignorespace  # not save commands that space-beginned and duplicated to history
export HISTIGNORE='?:??:???:history:cd*:exit:clear'

if [ -z "$EDITOR" ] && type vim &> /dev/null; then
    export EDITOR='vim -p'
fi
if [ -z "$EDITOR" ]; then
    export EDITOR='vi -p'
fi

if type less &> /dev/null; then
  export PAGER='less'
  export LESS='RFMi'
  export LESS_TERMCAP_mb=$'\E[1;31m'   # Begins blinking.
  export LESS_TERMCAP_md=$'\E[36m'     # Begins bold.
  export LESS_TERMCAP_so=$'\E[47;30m'  # Begins standout-mode.
  export LESS_TERMCAP_us=$'\E[1;36m'   # Begins underline.
  export LESS_TERMCAP_me=$'\E[0m'      # Ends mode.
  export LESS_TERMCAP_se=$'\E[0m'      # Ends standout-mode.
  export LESS_TERMCAP_ue=$'\E[0m'      # Ends underline.
fi

export SIMPLE_BACKUP_SUFFIX=.`date +%Y%m%d_%H%M%S`

[[ "${WSL_DISTRO_NAME}" ]] && export BROWSER=wslview

export LANG=C
LOCALE_LIST="$(locale -a)"
if [[ "${LOCALE_LIST}" == *C.UTF-8* ]]; then
  export LC_CTYPE='C.UTF-8'
fi

stty start ''
stty stop ''

export FZF_DEFAULT_OPTS='--reverse --cycle --bind "change:top" -0'

export ENHANCD_FILTER=fzf
export ENHANCD_ENABLE_SINGLE_DOT=false
export ENHANCD_ARG_DOUBLE_DOT=...

# exec commands after each commands
function dispatch_prompt_command() {
  local f
  for f in ${!PROMPT_COMMAND_*}; do
    eval "${!f}"
  done
}
export PROMPT_COMMAND='dispatch_prompt_command'

function __dedup_history() {
  history -a

  cmd='
import re
import operator
from typing import List, Optional, Dict
from os.path import expanduser

timestamp_pattern = re.compile("^#\d+$")
home = expanduser("~")
history_path = f"{home}/.bash_history"


def load_history() -> List[str]:
    with open(history_path) as f:
        return f.read().splitlines()


def extract_last_command(history: List[str]) -> Optional[str]:
    try:
        last_timestamp_line_num = next(
            i
            for i, line in reversed(list(enumerate(history)))
            if timestamp_pattern.fullmatch(line)
        )
        return "\n".join(history[last_timestamp_line_num + 1 :])
    except:
        return


def deduplicate_history(history: List[str]) -> List[str]:
    commands: Dict[str, str] = {}
    command = ""
    timestamp = ""
    for line in history:
        if timestamp_pattern.fullmatch(line):
            if command:
                commands[command.strip()] = timestamp
                command = ""
            timestamp = line
        else:
            command += line + "\n"

    if command:
        commands[command.strip()] = timestamp

    result: List[str] = []
    sorted_commands = sorted(commands.items(), key=operator.itemgetter(1))
    for command, timestamp in sorted_commands:
        result.append(timestamp)
        result.append(command)

    return result


def update_history(new_history: List[str]):
    out = "\n".join(new_history) + "\n"
    with open(history_path, "w") as f:
        f.write(out)


def main():
    if not home:
        return

    history = load_history()
    if len(history) <= 1:
        return

    last_command = extract_last_command(history)
    if not last_command:
        return

    new_history = deduplicate_history(history)
    update_history(new_history)


main()
'

  if type python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi

  history -c
  history -r
}
export PROMPT_COMMAND_HISTSAVE='__dedup_history'

function lsgit() {
  ls -A
  if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = "true" ] ; then
    echo
    git status -sb
  fi
}

function lsgit_cd() {
  if [ "${LSGIT_DIR:-${PWD}}" != "${PWD}" ]; then
    lsgit
  fi
  LSGIT_DIR=${PWD}
}
export PROMPT_COMMAND_LSGIT_CD='lsgit_cd'

trap '((cmdcnt++))' DEBUG
function lsgit_enter() {
  if [ $((lsgit_enter_cnt + 1)) = ${cmdcnt} ]; then
    lsgit
  fi

  lsgit_enter_cnt=${cmdcnt}
}
export PROMPT_COMMAND_LSGIT_ENTER='lsgit_enter'

# prompt
SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE:-$0}); pwd)

if [[ -n "${VIMRUNTIME}" ]]; then
    VIMLABEL="! "
    export PS1="${VIMLABEL}${PS1}"
fi

if type git &> /dev/null; then
    . ${SCRIPT_DIR}/git-prompt.sh

    # lighter
    export PS1='\n${VIMLABEL}\[\033[92m\]\u \[\033[93m\]&:\j \[\033[94m\]\w\[\033[91m\]$(__git_ps1)\n$(if [[ $? == "0" ]]; then echo \[\033[92m\]:\); else echo \[\033[91m\]:\(; fi)\[\033[00m\] '

    # darker
    #export PS1='\n\[\033[32m\]\u \[\033[33m\]&:\j \[\033[34m\]\w\[\033[31m\]$(__git_ps1)\n$(if [[ $? == "0" ]]; then echo \[\033[32m\]:\); else echo \[\033[31m\]:\(; fi)\[\033[00m\] '

    GIT_PS1_SHOWDIRTYSTATE=1  # show if files are changed or not
    GIT_PS1_SHOWUPSTREAM=1  # show diff from upstream
    GIT_PS1_DESCRIBE_STYLE=branch  # show detached HEAD as relative to branch
fi
