# __bfs_dir - breadth-first search for directories
function __bfs_dir() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    print(p)
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# __bfs_file - breadth-first search for files
function __bfs_file() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

for c in os.listdir('.'):
    if os.path.isfile(c):
        print(c)

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
        if os.path.isfile(child_path):
            print(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# fd - cd sorted by depth
function fd() {
  cd $(
    __bfs_dir 2> /dev/null |
      fzf +m +s -q ${1:-''} --preview "ls -p --group-directories-first --color=always {} 2> /dev/null"
  )
}

# fe - open selected files with EDITOR
function fe() {
  local files

  files=($(
    __bfs_file 2> /dev/null |
      fzf -m -q ${1:-''} --header "Tab: toggle"
  ))
  if [[ -n "$files" ]]; then
    eval "${EDITOR:-vim -p} $(printf '"%s" ' "${files[@]}")"
  fi
}

# gfe - open selected files with EDITOR only git tracked
function gfe() {
  local files

  files=($(
    git ls-files 2> /dev/null |
      fzf -m -q ${1:-''} --header "Tab: toggle"
  ))
  if [[ -n "$files" ]]; then
    eval "${EDITOR:-vim -p} $(printf '"%s" ' "${files[@]}")"
  fi
}

# gdfe - open selected files with EDITOR only git modified
function gdfe() {
  local files tmp_files
  tmp_files=$(git ls-files -o -m --exclude-standard $(git rev-parse --show-cdup) 2> /dev/null)
  files=($(echo "$tmp_files" | fzf -m -q ${1:-''} --header "Tab: toggle"))
  if [[ -n "$files" ]]; then
    eval "${EDITOR:-vim -p} $(printf '"%s" ' "${files[@]}")"
  fi
}

# gfco - git checkout branch
function gfco() {
  local tags branches target

  local_branches=$(
    git --no-pager branch \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mlocal%09%1B[m%(refname:short)%(end)%(end)") || return
  remote_branches=$(
    git --no-pager branch --remote \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mremote%09%1B[m%(refname:short)%(end)%(end)") || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$local_branches"; echo "$remote_branches"; echo "$tags") | sed '/^$/d' |
      fzf --no-hscroll --no-multi -n 2 -q ${1:-''} --header="current: [$(git symbolic-ref --short HEAD 2> /dev/null || echo 'detached HEAD')]" \
          --ansi --preview="git --no-pager log -150 --color --pretty=format:\"%s %C(black)%C(bold)%cr%C(reset)\" ..{2}") || return
  type=$(echo "$target" | cut -d$'\t' -f1)
  name=$(echo "$target" | cut -d$'\t' -f2)
  if [[ $type == remote ]]; then
    { git checkout -t "$name" || git checkout "${name#*/}"; } 2> /dev/null
  else
    git checkout "$name" 2> /dev/null
  fi
}

# gfbd - git delete branches
function gfbd() {
  git --no-pager branch \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%(refname:short)%(end)%(end)" |
    sed '/^$/d' |
    fzf -m --no-hscroll -q ${1:-''} --header="Tab: toggle" |
    xargs -r git branch -D
}

# gfshow - git show commit
# can specify file
function gfshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index \
        --preview "echo {} | \grep -Eo '[a-f0-9]+' | head -1 | \
                  xargs -I % git diff-tree --no-commit-id --name-status -r %" \
        --bind "ctrl-m:execute: \
                  (echo {} | \grep -Eo '[a-f0-9]+' | head -1 | \
                  xargs -I % git show --color=always % | LESS= less -R)"
}

# gfcf - git commit fixup
function gfcf() {
  local target

  if git diff --cached --quiet; then
    echo "No staged changes."
    return
  fi

  target=$(
    git log --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" |
      fzf --ansi --no-sort --reverse --tiebreak=index \
          --preview "echo {} | \grep -Eo '[a-f0-9]+' | head -1 | \
                      xargs -I % git diff-tree --no-commit-id --name-status -r %") || return
  git commit --fixup "$(cut -d' ' -f1 <<< "${target}")" "$@"
}

# dfl - docker logs
function dfl() {
  local name
  name=$(docker ps -a | sed 1d | fzf --no-sort -n 2,-1 | awk '{print $NF}')

  [ -n "$name" ] && docker logs "$name" "$@"
}

# dfr - docker run
function dfr() {
  local image
  image=$(docker images | sed 1d | fzf --no-sort -n 1,2 | awk '{print $1 ":" $2}')

  [ -n "$image" ] && docker run "$image" "$@"
}

# dfrr - docker run rm
function dfrr() {
  local image
  image=$(docker images | sed 1d | fzf --no-sort -n 1,2 | awk '{print $1 ":" $2}')

  [ -n "$image" ] && docker run --rm "$image" "$@"
}

# dfri - docker run interactive
function dfri() {
  local image
  image=$(docker images | sed 1d | fzf --no-sort -n 1,2 | awk '{print $1 ":" $2}')

  [ -n "$image" ] && docker run -it "$image" "$@"
}

# dfrir - docker run interactive rm
function dfrir() {
  local image
  image=$(docker images | sed 1d | fzf --no-sort -n 1,2 | awk '{print $1 ":" $2}')

  [ -n "$image" ] && docker run -it --rm "$image" "$@"
}

# dfx - docker exec
function dfx() {
  local name
  name=$(docker ps -a | sed 1d | fzf --no-sort -n 2,-1 | awk '{print $NF}')

  [ -n "$name" ] && docker start "$name" && docker exec "$name" "$@"
}

# dfxi - docker exec interactive
function dfxi() {
  local name
  name=$(docker ps -a | sed 1d | fzf --no-sort -n 2,-1 | awk '{print $NF}')

  [ -n "$name" ] && docker start "$name" && docker exec -it "$name" "$@"
}

# dfa - docker attach
function dfa() {
  local name
  name=$(docker ps -a | sed 1d | fzf --no-sort -1 -q "$1" -n 2,-1 | awk '{print $NF}')

  [ -n "$name" ] && docker start "$name" && docker attach "$name"
}

# dfstart - docker start
function dfstart() {
  docker ps -a | sed 1d | fzf --no-sort -q "$1" -m -n 2,-1 | awk '{ print $NF }' | xargs -r docker start
}

# dfstop - docker stop
function dfstop() {
  docker ps | sed 1d | fzf --no-sort -q "$1" -m --tac -n 2,-1 | awk '{ print $NF }' | xargs -r docker stop
}

# dfrestart - docker restart
function dfrestart() {
  docker ps -a | sed 1d | fzf --no-sort -q "$1" -m -n 2,-1 | awk '{ print $NF }' | xargs -r docker restart
}

# dfcor - docker container rm
function dfcor() {
  docker ps -a | sed 1d | fzf --no-sort -q "$1" -m --tac -n 2,-1 | awk '{ print $NF }' | xargs -r docker container rm
}

# dfcorv - docker container rm -v
function dfcorv() {
  docker ps -a | sed 1d | fzf --no-sort -q "$1" -m --tac -n 2,-1 | awk '{ print $NF }' | xargs -r docker container rm -v
}

# dfir - docker image rm
function dfir() {
  docker images | sed 1d | fzf --no-sort -q "$1" -m --tac -n 1,2 | awk '{ print $1 ":" $2 }' | xargs -r docker image rm
}

# dfvr - docker volume rm
function dfvr() {
  docker volume ls | sed 1d | fzf --no-sort -q "$1" -m --tac -n 2 | awk '{ print $NF }' | xargs -r docker volume rm
}
