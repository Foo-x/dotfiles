# use in your .bash_profile or .bashrc like below
# . /path/to/dotfiles/.aliases_fzf

# __bfs_dir - breadth-first search for directories
function __bfs_dir() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    print(p)
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# __bfs_file - breadth-first search for files
function __bfs_file() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

for c in os.listdir('.'):
    if os.path.isfile(c):
        print(c)

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
        if os.path.isfile(child_path):
            print(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# f- - cd to history
function f-() {
  local target=$(dirs -v | sort -k 2 | uniq -f 1 | sort -n -k 1 | tail -n +2 | awk '{print $2}' | fzf -q ${1:-''})

  if [ -n "$target" ]; then
    cd "$(echo "$target" | sed "s;^~;$HOME;")"
  fi
}

# f.. - cd to parent
function f..() {
  local paths=$(cd .. && pwd | tr "/" "\n") null="/dev/null"
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && null="nul"

  local selected="$(
    (
    for i in $(seq 1 $(echo "${paths}" | wc -l)); do
      echo "${paths}" | head -n $i | tr "\n" "/"
      echo
    done
    ) | sed '1!G;h;$!d' | fzf -q ${1:-''} --preview "ls -p --group-directories-first --color=always {} 2> ${null}")"

  if [[ "$selected" ]]; then
    cd "${selected}"
  fi
}

# fd - cd sorted by depth
function fd() {
  local dir null="/dev/null" conv="cat -" sh
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && null="nul" && conv="iconv -f SJIS -t UTF-8" && sh="bash -ci"

  dir=$(
    ${sh} __bfs_dir 2> /dev/null |
    ${conv} |
    fzf +m +s -q ${1:-''} --preview "ls -p --group-directories-first --color=always {} 2> ${null}"
  ) && cd "$dir"
}

# fe - open selected files with EDITOR
function fe() {
  local files conv="cat -" sh
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && conv="iconv -f SJIS -t UTF-8" && sh="bash -ci"

  files=($(
    ${sh} __bfs_file 2> /dev/null |
    ${conv} |
    fzf -m -q ${1:-''} --header "Tab: toggle"
  ))
  if [[ -n "$files" ]]; then
    local files_str="$(printf '"%s" ' "${files[@]}")"
    eval "${EDITOR:-vim -p} ${files_str}"
  fi
}

# fb - cd to bookmark
function fb() {
  local bfile=~/.fb dir matched usage OPT OPTARG OPTIND
  touch ${bfile}

  usage=$(
    echo "Usage:"
    echo "  fb [-a NAME | -u NAME | -d NAME | -l | -e | QUERY]"
    echo ""
    echo "Description:"
    echo "  Save and jump to bookmarks."
    echo ""
    echo "Options:"
    echo "  -a NAME  Save the current dir as NAME"
    echo "  -u NAME  Save or Update the current dir as NAME"
    echo "  -d NAME  Delete NAME from bookmarks"
    echo "  -l       List all bookmarks"
    echo "  -e       Edit bookmarks-file"
    echo "  QUERY    Jump to bookmark filtered with QUERY (optional)"
  )

  while getopts -- ":-:a:u:d:le" OPT; do
    case $OPT in
      a)
        if matched=$(\grep "^$OPTARG=" ${bfile}); then
          echo "'$OPTARG' is already saved: $(echo ${matched} | cut -d '=' -f2)"
          return 1
        fi
        echo "$OPTARG=$(pwd)" >> ${bfile}
        echo "Saved: $OPTARG=$(pwd)"
        return
        ;;
      u)
        sed -i "/^$OPTARG=/d" ${bfile}
        echo "$OPTARG=$(pwd)" >> ${bfile}
        echo "Saved: $OPTARG=$(pwd)"
        return
        ;;
      d)
        if ! \grep "^$OPTARG=" ${bfile} > /dev/null; then
          echo "'$OPTARG' is not saved yet."
          return 1
        fi
        sed -i "/^$OPTARG=/d" ${bfile}
        echo "Deleted: $OPTARG"
        return
        ;;
      l)
        cat ${bfile} | awk -F '=' '{printf "\033[34m%-20s\033[0m %s\n", $1, $2}'
        return
        ;;
      e)
        eval "${EDITOR} ${bfile}"
        return
        ;;
      *)
        echo -e "${usage}"
        return
        ;;
    esac
  done

  if [[ $OPTIND == 1 ]]; then
    dir=$(
      cat ${bfile} | awk -F '=' '{printf "\033[34m%-20s\033[0m %s\n", $1, $2}' | fzf +m --ansi -q ${1:-''} -n1 -1
    ) && cd "$(echo "${dir}" | cut -d ' ' -f2- | sed "s/^ *//")"
  fi
}

# fh - repeat history
function fh() {
  local command=$( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | sort -k 2 -k 1rn | uniq -f 1 | sort -n | fzf -q ${1:-''} --tac | sed -r 's/ *[-0-9 :]*\*? *//' | sed -r 's/\\/\\\\/g')
  history -s "${command}"
  history -s "${FUNCNAME[0]}"
  eval "${command}"
}

# fhe - repeat history edit
writecmd (){ perl -e 'ioctl STDOUT, 0x5412, $_ for split //, do{ chomp($_ = <>); $_ }' ; }

fhe() {
  ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | sort -k 2 -k 1rn | uniq -f 1 | sort -n | fzf -q ${1:-''} --tac | sed -r 's/ *[-0-9 :]*\*? *//' | sed -r 's/\\/\\\\/g' | writecmd
  history -s "${FUNCNAME[0]}"
}

# gfco - checkout branch
function gfco() {
  local tags branches target

  branches=$(
    git --no-pager branch --all \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)") || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") | sed '/^$/d' |
    fzf --no-hscroll --no-multi -n 2 -q ${1:-''} --header="current: [$(git symbolic-ref --short HEAD 2> /dev/null || echo 'detached HEAD')]" \
        --ansi --preview="git --no-pager log -150 --color --pretty=format:\"%s %C(black)%C(bold)%cr%C(reset)\" ..{2}") || return
  { git checkout -t $(awk '{print $2}' <<< "$target") || git checkout $(awk '{print $2}' <<< "$target"); } 2> /dev/null
}

# gfbd - delete branches
function gfbd() {
  local tags branches target

  target=$(
    git --no-pager branch \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%(refname:short)%(end)%(end)" |
    sed '/^$/d' |
    fzf -m --no-hscroll -q ${1:-''} --header="Tab: toggle") || return
  git branch -D ${target}
}

# gfshow - show commit
# can specify file
function gfshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index \
      --preview "echo {} | bash -c \"\grep -Eo '[a-f0-9]+' | head -1 | \
                xargs -I % git diff-tree --no-commit-id --name-status -r %\"" \
      --bind "ctrl-m:execute: \
                (echo {} | bash -c \"\grep -Eo '[a-f0-9]+' | head -1 | \
                xargs -I % bash -c 'export TERM=xterm; git show --color=always % | less -R'\")"
}

# gfa - add selected
function gfa() {
  local selected unstaged preview="echo {2} | xargs git diff --color"
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && preview=""

  unstaged=$(git status -s | \grep "^.[^ ]" | awk '{print $2}')
  if [[ ! ${unstaged} ]]; then
    return
  fi

  selected=$(git -c color.status=always status -s |
    \grep -f <(echo -e "${unstaged}") |
    fzf -m --ansi -q ${1:-''} --header "Tab: toggle" --preview "${preview}" |
    awk '{print $2}')

  if [[ "${selected}" ]]; then
    echo "${selected}" | xargs git add
    echo -e "git add:\n$(echo -e "${selected}")"
  fi
}

# gfus - unstage selected
function gfus() {
  local selected staged preview="echo {2} | xargs git diff --cached --color"
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && preview=""

  staged=$(git status -s | \grep "^[^ ?]" | awk '{print $2}')
  if [[ ! ${staged} ]]; then
    return
  fi

  selected=$(git -c color.status=always status -s |
    \grep -f <(echo -e "${staged}") |
    fzf -m --ansi -q ${1:-''} --header "Tab: toggle" --preview "${preview}" |
    awk '{print $2}')

  if [[ "${selected}" ]]; then
    echo "${selected}" | xargs git reset -q HEAD
    echo -e "git unstage:\n$(echo -e "${selected}")"
  fi
}
