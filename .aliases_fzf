# __bfs_dir - breadth-first search for directories
function __bfs_dir() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    print(p)
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# __bfs_file - breadth-first search for files
function __bfs_file() {
  local cmd ignore_ptn="\.git|node_modules"

  cmd="
import os
import re
from collections import deque

for c in os.listdir('.'):
    if os.path.isfile(c):
        print(c)

pattern = re.compile('${ignore_ptn}')

q = deque([c for c in os.listdir('.') if os.path.isdir(c) and not pattern.match(c)])

while len(q) > 0:
    p = q.popleft()
    for c in os.listdir(p):
        if pattern.match(c):
            continue
        child_path = p + '/' + c
        if os.path.isdir(child_path):
            q.append(child_path)
        if os.path.isfile(child_path):
            print(child_path)
"
  if which python &> /dev/null; then
    python -c "$cmd"
  else
    python3 -c "$cmd"
  fi
}

# fd - cd sorted by depth
function fd() {
  local dir null="/dev/null" conv="cat -" sh
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && null="nul" && conv="iconv -f SJIS -t UTF-8" && sh="bash -ci"

  dir=$(
    ${sh} __bfs_dir 2> /dev/null |
    ${conv} |
    fzf +m +s -q ${1:-''} --preview "ls -p --group-directories-first --color=always {} 2> ${null}"
  ) && cd "$dir"
}

# fe - open selected files with EDITOR
function fe() {
  local files conv="cat -" sh
  [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]] && conv="iconv -f SJIS -t UTF-8" && sh="bash -ci"

  files=($(
    ${sh} __bfs_file 2> /dev/null |
    ${conv} |
    fzf -m -q ${1:-''} --header "Tab: toggle"
  ))
  if [[ -n "$files" ]]; then
    local files_str="$(printf '"%s" ' "${files[@]}")"
    eval "${EDITOR:-vim -p} ${files_str}"
  fi
}

# gfco - checkout branch
function gfco() {
  local tags branches target

  branches=$(
    git --no-pager branch --all \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)") || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") | sed '/^$/d' |
    fzf --no-hscroll --no-multi -n 2 -q ${1:-''} --header="current: [$(git symbolic-ref --short HEAD 2> /dev/null || echo 'detached HEAD')]" \
        --ansi --preview="git --no-pager log -150 --color --pretty=format:\"%s %C(black)%C(bold)%cr%C(reset)\" ..{2}") || return
  { git checkout -t $(awk '{print $2}' <<< "$target") || git checkout $(awk '{print $2}' <<< "$target"); } 2> /dev/null
}

# gfbd - delete branches
function gfbd() {
  local tags branches target

  target=$(
    git --no-pager branch \
        --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%(refname:short)%(end)%(end)" |
    sed '/^$/d' |
    fzf -m --no-hscroll -q ${1:-''} --header="Tab: toggle") || return
  git branch -D ${target}
}

# gfshow - show commit
# can specify file
function gfshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index \
      --preview "echo {} | bash -c \"\grep -Eo '[a-f0-9]+' | head -1 | \
                xargs -I % git diff-tree --no-commit-id --name-status -r %\"" \
      --bind "ctrl-m:execute: \
                (echo {} | bash -c \"\grep -Eo '[a-f0-9]+' | head -1 | \
                xargs -I % bash -c 'export TERM=xterm; git show --color=always % | less -R'\")"
}

# gfcf - commit fixup
function gfcf() {
  local target

  if git diff --cached --quiet; then
    echo "No staged changes."
    return
  fi

  target=$(
    git log --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" |
    fzf --ansi --no-sort --reverse --tiebreak=index \
        --preview "echo {} | bash -c \"\grep -Eo '[a-f0-9]+' | head -1 | \
                    xargs -I % git diff-tree --no-commit-id --name-status -r %\"") || return
  git commit --fixup "$(cut -d' ' -f1 <<< "${target}")" "$@"
}
